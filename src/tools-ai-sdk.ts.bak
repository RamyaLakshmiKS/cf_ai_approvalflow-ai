import { tool } from "ai";
import { z } from "zod";
import handbookContent from "../docs/employee_handbook.md?raw";
import { getHandbookSearchPrompt } from "./prompts";

/**
 * Tool execution context interface
 */
export interface ToolContext {
  env: Env;
  userId: string;
}

/**
 * Creates AI SDK tools with access to the tool context
 */
export function createTools(context: ToolContext) {
  return {
    get_current_user: tool({
      description:
        "Retrieves the authenticated user's profile including ID, name, role, employee level, and manager. Use this first to understand who is making the request.",
      parameters: z.object({}),
      execute: async () => {
        console.log(
          "[TOOL] get_current_user called for userId:",
          context.userId
        );
        const user = await context.env.APP_DB.prepare(
          "SELECT id, username, employee_level, manager_id, hire_date, department, role FROM users WHERE id = ?"
        )
          .bind(context.userId)
          .first();

        if (!user) {
          console.warn(
            "[TOOL] get_current_user - User not found:",
            context.userId
          );
          throw new Error("User not found");
        }

        console.log(
          "[TOOL] get_current_user - Retrieved user:",
          (user as { username: string }).username
        );
        return user;
      }
    }),

    search_employee_handbook: tool({
      description:
        "Searches the employee handbook to find relevant policies and rules. Use this for any policy-related questions or validations about PTO, expenses, benefits, blackout periods, auto-approval limits, etc.",
      parameters: z.object({
        query: z
          .string()
          .describe(
            "Natural language query about company policies (e.g., 'What are the PTO auto-approval limits?', 'What are the blackout periods?', 'What is the expense reimbursement policy?')"
          )
      }),
      execute: async ({ query }) => {
        console.log(
          "[TOOL] search_employee_handbook called with query:",
          query
        );

        const prompt = getHandbookSearchPrompt(handbookContent, query);

        const response = (await context.env.AI.run(
          "@cf/meta/llama-3.1-8b-instruct" as keyof AiModels,
          {
            messages: [{ role: "user", content: prompt }],
            max_tokens: 500
          }
        )) as { response?: string };
        console.log("[TOOL] search_employee_handbook - Got response from AI");

        return {
          answer: response.response || String(response),
          source: "Employee Handbook"
        };
      }
    }),

    get_pto_balance: tool({
      description:
        "Retrieves the employee's current PTO balance, accrued days, used days, and rollover information.",
      parameters: z.object({
        employee_id: z
          .string()
          .optional()
          .describe("The employee's ID (optional, defaults to current user)")
      }),
      execute: async ({ employee_id }) => {
        const userId = employee_id || context.userId;
        console.log("[TOOL] get_pto_balance called for employee:", userId);

        const ptoBalance = await context.env.APP_DB.prepare(
          "SELECT current_balance, total_accrued, total_used, rollover_from_previous_year FROM pto_balances WHERE employee_id = ?"
        )
          .bind(userId)
          .first();

        if (!ptoBalance) {
          console.warn(
            "[TOOL] get_pto_balance - No balance found for employee:",
            userId
          );
          return {
            error: "PTO balance not found for this employee",
            current_balance: 0,
            total_accrued: 0,
            total_used: 0,
            rollover_from_previous_year: 0
          };
        }

        console.log("[TOOL] get_pto_balance - Retrieved balance:", {
          current_balance: (ptoBalance as { current_balance: number })
            .current_balance
        });
        return ptoBalance;
      }
    }),

    check_blackout_periods: tool({
      description:
        "Checks if the requested dates overlap with company blackout periods (fiscal quarter ends, holidays). Use this to validate PTO requests.",
      parameters: z.object({
        start_date: z
          .string()
          .describe("Start date in ISO 8601 format (YYYY-MM-DD)"),
        end_date: z
          .string()
          .describe("End date in ISO 8601 format (YYYY-MM-DD)")
      }),
      execute: async ({ start_date, end_date }) => {
        console.log("[TOOL] check_blackout_periods called for dates:", {
          start_date,
          end_date
        });

        const blackouts = await context.env.APP_DB.prepare(
          `SELECT * FROM company_calendar 
          WHERE event_type = 'blackout' 
          AND (
            (start_date BETWEEN ?1 AND ?2) OR 
            (end_date BETWEEN ?1 AND ?2) OR
            (?1 BETWEEN start_date AND end_date) OR
            (?2 BETWEEN start_date AND end_date)
          )`
        )
          .bind(start_date, end_date)
          .all();

        console.log(
          "[TOOL] check_blackout_periods - Found",
          blackouts.results.length,
          "conflicts"
        );
        return {
          has_conflict: blackouts.results.length > 0,
          conflicting_periods: blackouts.results
        };
      }
    }),

    get_pto_history: tool({
      description:
        "Retrieves past PTO requests for the employee, including approved, denied, and pending requests.",
      parameters: z.object({
        employee_id: z
          .string()
          .optional()
          .describe("Employee ID (optional, defaults to current user)"),
        limit: z
          .number()
          .optional()
          .describe("Maximum number of records to return (default: 10)"),
        status_filter: z
          .enum(["approved", "denied", "pending", "all"])
          .optional()
          .describe("Filter by status: approved, denied, pending, or all")
      }),
      execute: async ({ employee_id, limit = 10, status_filter = "all" }) => {
        const userId = employee_id || context.userId;
        console.log("[TOOL] get_pto_history called with:", {
          userId,
          limit,
          status_filter
        });

        let query = "SELECT * FROM pto_requests WHERE employee_id = ?";
        const queryParams: string[] = [userId];

        if (status_filter && status_filter !== "all") {
          query += " AND status = ?";
          queryParams.push(status_filter);
        }

        query += " ORDER BY created_at DESC LIMIT ?";
        queryParams.push(limit.toString());

        const history = await context.env.APP_DB.prepare(query)
          .bind(...queryParams)
          .all();
        console.log(
          "[TOOL] get_pto_history - Retrieved",
          (history.results as unknown[]).length,
          "records"
        );
        return history.results;
      }
    }),

    calculate_business_days: tool({
      description:
        "Calculates the number of business days (excluding weekends and holidays) between two dates. Use this to determine the actual PTO days needed.",
      parameters: z.object({
        start_date: z
          .string()
          .describe("Start date in ISO 8601 format (YYYY-MM-DD)"),
        end_date: z
          .string()
          .describe("End date in ISO 8601 format (YYYY-MM-DD)")
      }),
      execute: async ({ start_date, end_date }) => {
        console.log("[TOOL] calculate_business_days called for:", {
          start_date,
          end_date
        });

        const startDate = new Date(start_date);
        const endDate = new Date(end_date);

        const holidays = await context.env.APP_DB.prepare(
          `SELECT start_date FROM company_calendar 
          WHERE event_type = 'holiday' 
          AND start_date BETWEEN ?1 AND ?2`
        )
          .bind(start_date, end_date)
          .all();

        const holidaySet = new Set(
          (holidays.results as { start_date: string }[]).map(
            (h) => h.start_date
          )
        );

        let businessDays = 0;
        let weekendDays = 0;
        const current = new Date(startDate);

        while (current <= endDate) {
          const dayOfWeek = current.getDay();
          const dateStr = current.toISOString().split("T")[0];

          if (dayOfWeek === 0 || dayOfWeek === 6) {
            weekendDays++;
          } else if (!holidaySet.has(dateStr)) {
            businessDays++;
          }

          current.setDate(current.getDate() + 1);
        }

        console.log("[TOOL] calculate_business_days - Calculated:", {
          businessDays,
          weekendDays,
          holidays: Array.from(holidaySet).length
        });
        return {
          business_days: businessDays,
          weekend_days: weekendDays,
          holidays: Array.from(holidaySet)
        };
      }
    }),

    validate_pto_policy: tool({
      description:
        "Validates a PTO request against all company policies: balance, blackouts, and auto-approval limits. Use this before submitting a PTO request.",
      parameters: z.object({
        employee_id: z.string().describe("Employee ID"),
        start_date: z
          .string()
          .describe("Start date in ISO 8601 format (YYYY-MM-DD)"),
        end_date: z
          .string()
          .describe("End date in ISO 8601 format (YYYY-MM-DD)"),
        reason: z.string().optional().describe("Reason for PTO request")
      }),
      execute: async ({ employee_id, start_date, end_date, reason }) => {
        console.log("[TOOL] validate_pto_policy called with:", {
          employee_id,
          start_date,
          end_date
        });

        const violations: Array<{ policy: string; message: string }> = [];

        const employee = await context.env.APP_DB.prepare(
          "SELECT employee_level FROM users WHERE id = ?"
        )
          .bind(employee_id)
          .first();

        if (!employee) {
          console.error(
            "[TOOL] validate_pto_policy - Employee not found:",
            employee_id
          );
          throw new Error("Employee not found");
        }

        // Get balance
        const balanceResult = await context.env.APP_DB.prepare(
          "SELECT current_balance FROM pto_balances WHERE employee_id = ?"
        )
          .bind(employee_id)
          .first();

        // Calculate business days
        const startDate = new Date(start_date);
        const endDate = new Date(end_date);
        const holidays = await context.env.APP_DB.prepare(
          `SELECT start_date FROM company_calendar 
          WHERE event_type = 'holiday' 
          AND start_date BETWEEN ?1 AND ?2`
        )
          .bind(start_date, end_date)
          .all();

        const holidaySet = new Set(
          (holidays.results as { start_date: string }[]).map(
            (h) => h.start_date
          )
        );

        let businessDays = 0;
        const current = new Date(startDate);
        while (current <= endDate) {
          const dayOfWeek = current.getDay();
          const dateStr = current.toISOString().split("T")[0];
          if (
            dayOfWeek !== 0 &&
            dayOfWeek !== 6 &&
            !holidaySet.has(dateStr)
          ) {
            businessDays++;
          }
          current.setDate(current.getDate() + 1);
        }

        // Rule 1: Sufficient balance
        if (
          balanceResult &&
          (balanceResult as { current_balance: number }).current_balance <
            businessDays
        ) {
          violations.push({
            policy: "insufficient_balance",
            message: `Insufficient PTO balance. You have ${(balanceResult as { current_balance: number }).current_balance} days available, but you're requesting ${businessDays} business days.`
          });
        }

        // Rule 2: No blackout conflicts
        const blackouts = await context.env.APP_DB.prepare(
          `SELECT * FROM company_calendar 
          WHERE event_type = 'blackout' 
          AND (
            (start_date BETWEEN ?1 AND ?2) OR 
            (end_date BETWEEN ?1 AND ?2) OR
            (?1 BETWEEN start_date AND end_date) OR
            (?2 BETWEEN start_date AND end_date)
          )`
        )
          .bind(start_date, end_date)
          .all();

        if (blackouts.results.length > 0) {
          const period = blackouts.results[0] as {
            name?: string;
            start_date: string;
            end_date: string;
          };
          violations.push({
            policy: "blackout_conflict",
            message: `Request overlaps with blackout period: ${period.name || "Company blackout"} (${period.start_date} to ${period.end_date})`
          });
        }

        // Rule 3: Auto-approval threshold
        const autoApprovalLimit =
          (employee as { employee_level: string }).employee_level === "senior"
            ? 10
            : 3;
        const canAutoApprove =
          businessDays <= autoApprovalLimit && violations.length === 0;
        const requiresEscalation =
          businessDays > autoApprovalLimit && violations.length === 0;

        console.log("[TOOL] validate_pto_policy - Validation result:", {
          canAutoApprove,
          requiresEscalation,
          violationCount: violations.length
        });

        return {
          is_valid: violations.length === 0,
          can_auto_approve: canAutoApprove,
          requires_escalation: requiresEscalation,
          violations,
          business_days_requested: businessDays,
          auto_approval_limit: autoApprovalLimit,
          recommendation: canAutoApprove
            ? "AUTO_APPROVE"
            : requiresEscalation
              ? "ESCALATE_TO_MANAGER"
              : "DENY"
        };
      }
    }),

    submit_pto_request: tool({
      description:
        "Submits a PTO request to the database after validation. Sets status based on auto-approval or escalation. Only use this AFTER validating with validate_pto_policy.",
      parameters: z.object({
        employee_id: z.string().describe("Employee ID"),
        start_date: z
          .string()
          .describe("Start date in ISO 8601 format (YYYY-MM-DD)"),
        end_date: z
          .string()
          .describe("End date in ISO 8601 format (YYYY-MM-DD)"),
        total_days: z.number().describe("Total business days requested"),
        reason: z.string().optional().describe("Reason for PTO request"),
        status: z
          .enum(["auto_approved", "pending", "denied"])
          .describe("Status of the request"),
        approval_type: z
          .enum(["auto", "manual"])
          .describe("Type of approval"),
        validation_notes: z
          .string()
          .optional()
          .describe("Notes from validation process")
      }),
      execute: async ({
        employee_id,
        start_date,
        end_date,
        total_days,
        reason,
        status,
        approval_type,
        validation_notes
      }) => {
        const requestId = crypto.randomUUID();
        console.log("[TOOL] submit_pto_request called with:", {
          employee_id,
          total_days,
          status
        });

        const employee = await context.env.APP_DB.prepare(
          "SELECT manager_id FROM users WHERE id = ?"
        )
          .bind(employee_id)
          .first();

        await context.env.APP_DB.prepare(
          `INSERT INTO pto_requests (
            id, employee_id, manager_id, start_date, end_date,
            total_days, reason, status, approval_type, ai_validation_notes
          ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`
        )
          .bind(
            requestId,
            employee_id,
            (employee as { manager_id: string }).manager_id,
            start_date,
            end_date,
            total_days,
            reason || "",
            status,
            approval_type,
            validation_notes || ""
          )
          .run();

        if (status === "auto_approved") {
          console.log(
            "[TOOL] submit_pto_request - Auto-approving and updating balance"
          );
          await context.env.APP_DB.prepare(
            "UPDATE pto_balances SET total_used = total_used + ?, current_balance = current_balance - ? WHERE employee_id = ?"
          )
            .bind(total_days, total_days, employee_id)
            .run();
        }

        // Log audit event
        await context.env.APP_DB.prepare(
          `INSERT INTO audit_log (id, entity_type, entity_id, action, actor_id, actor_type, details)
           VALUES (?, ?, ?, ?, ?, ?, ?)`
        )
          .bind(
            crypto.randomUUID(),
            "pto_request",
            requestId,
            "created",
            context.userId,
            "ai_agent",
            JSON.stringify({
              status,
              approval_type,
              days_requested: total_days
            })
          )
          .run();

        console.log(
          "[TOOL] submit_pto_request - Request created successfully:",
          requestId
        );

        return {
          request_id: requestId,
          status: status,
          message: "Request submitted successfully"
        };
      }
    }),

    log_audit_event: tool({
      description:
        "Logs an action to the audit trail for compliance and tracking. Use this for all significant actions.",
      parameters: z.object({
        entity_type: z
          .string()
          .describe(
            "Type of entity (e.g., 'pto_request', 'expense_request', 'user')"
          ),
        entity_id: z.string().describe("ID of the entity"),
        action: z
          .string()
          .describe(
            "Action performed (e.g., 'created', 'approved', 'denied', 'updated')"
          ),
        details: z
          .record(z.unknown())
          .optional()
          .describe("Additional details about the action")
      }),
      execute: async ({ entity_type, entity_id, action, details }) => {
        console.log("[TOOL] log_audit_event:", {
          entity_type,
          entity_id,
          action
        });

        await context.env.APP_DB.prepare(
          `INSERT INTO audit_log (id, entity_type, entity_id, action, actor_id, actor_type, details)
           VALUES (?, ?, ?, ?, ?, ?, ?)`
        )
          .bind(
            crypto.randomUUID(),
            entity_type,
            entity_id,
            action,
            context.userId,
            "ai_agent",
            details ? JSON.stringify(details) : null
          )
          .run();

        console.log(
          "[TOOL] log_audit_event - Audit event logged successfully"
        );
        return { success: true };
      }
    })
  };
}
